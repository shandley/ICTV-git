"""
Report Generation Utilities

Generate professional PDF reports and data exports for committee use.
"""

import pandas as pd
import numpy as np
from datetime import datetime
import json
import io
from pathlib import Path
from typing import Dict, List, Any, Optional
import base64

# For PDF generation (using matplotlib for now, can upgrade to ReportLab)
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.backends.backend_pdf import PdfPages

class ReportGenerator:
    """Generate professional reports for ICTV committee."""
    
    def __init__(self):
        """Initialize report generator."""
        self.report_date = datetime.now()
        
    def generate_executive_summary(self, 
                                 system_health: Dict[str, Any],
                                 high_risk_families: List[Dict[str, Any]],
                                 recommendations: List[str]) -> bytes:
        """Generate executive summary PDF."""
        
        # Create PDF buffer
        pdf_buffer = io.BytesIO()
        
        with PdfPages(pdf_buffer) as pdf:
            # Page 1: Cover page
            fig = plt.figure(figsize=(8.5, 11))
            fig.patch.set_facecolor('white')
            
            # Remove axes
            ax = fig.add_subplot(111)
            ax.axis('off')
            
            # Title
            ax.text(0.5, 0.9, 'ICTV Family Risk Assessment', 
                   ha='center', va='top', fontsize=24, weight='bold')
            
            ax.text(0.5, 0.85, 'Executive Summary', 
                   ha='center', va='top', fontsize=18)
            
            # Date
            ax.text(0.5, 0.8, self.report_date.strftime('%B %Y'), 
                   ha='center', va='top', fontsize=14)
            
            # Key metrics box
            rect = patches.FancyBboxPatch((0.1, 0.4), 0.8, 0.3,
                                        boxstyle="round,pad=0.02",
                                        facecolor='lightblue',
                                        edgecolor='navy',
                                        linewidth=2)
            ax.add_patch(rect)
            
            # Metrics text
            metrics_text = f"""System Stability: {int(system_health['system_stability'] * 10)}%
Total Families: {system_health['total_families']}
Average Risk: {system_health['average_risk']:.1f}/10
Families Requiring Action: {len(high_risk_families)}"""
            
            ax.text(0.5, 0.55, metrics_text,
                   ha='center', va='center', fontsize=12,
                   linespacing=2.0)
            
            # Footer
            ax.text(0.5, 0.1, 'Generated by ICTV Risk Assessment Dashboard',
                   ha='center', va='bottom', fontsize=10, style='italic')
            
            pdf.savefig(fig, bbox_inches='tight')
            plt.close()
            
            # Page 2: High-risk families
            fig = plt.figure(figsize=(8.5, 11))
            fig.patch.set_facecolor('white')
            ax = fig.add_subplot(111)
            ax.axis('off')
            
            # Title
            ax.text(0.5, 0.95, 'Families Requiring Immediate Attention',
                   ha='center', va='top', fontsize=18, weight='bold')
            
            # Table data
            if high_risk_families:
                table_data = []
                for family in high_risk_families[:10]:  # Top 10
                    table_data.append([
                        family['family_name'],
                        f"{family['risk_score']:.1f}",
                        family['intervention_type'],
                        f"{family['current_size']}"
                    ])
                
                # Create table
                table = ax.table(cellText=table_data,
                               colLabels=['Family', 'Risk Score', 'Action', 'Size'],
                               cellLoc='left',
                               loc='upper center',
                               bbox=[0.1, 0.3, 0.8, 0.6])
                
                table.auto_set_font_size(False)
                table.set_fontsize(10)
                table.scale(1, 2)
                
                # Style header
                for i in range(4):
                    table[(0, i)].set_facecolor('#4472C4')
                    table[(0, i)].set_text_props(weight='bold', color='white')
            
            pdf.savefig(fig, bbox_inches='tight')
            plt.close()
            
            # Page 3: Recommendations
            fig = plt.figure(figsize=(8.5, 11))
            fig.patch.set_facecolor('white')
            ax = fig.add_subplot(111)
            ax.axis('off')
            
            # Title
            ax.text(0.5, 0.95, 'Strategic Recommendations',
                   ha='center', va='top', fontsize=18, weight='bold')
            
            # Recommendations
            y_pos = 0.85
            for i, rec in enumerate(recommendations[:5], 1):
                ax.text(0.1, y_pos, f"{i}. {rec}",
                       ha='left', va='top', fontsize=12,
                       wrap=True)
                y_pos -= 0.15
            
            pdf.savefig(fig, bbox_inches='tight')
            plt.close()
        
        pdf_buffer.seek(0)
        return pdf_buffer.getvalue()
    
    def generate_family_report(self, 
                             family_data: Dict[str, Any],
                             assessment: Dict[str, Any],
                             historical_data: Optional[List[Dict[str, Any]]] = None) -> bytes:
        """Generate detailed family report."""
        
        pdf_buffer = io.BytesIO()
        
        with PdfPages(pdf_buffer) as pdf:
            # Page 1: Family overview
            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(8.5, 11))
            fig.suptitle(f'{family_data["family_name"]} - Detailed Assessment', 
                        fontsize=16, weight='bold')
            
            # Risk gauge
            ax1.set_title('Risk Score')
            self._create_gauge_chart(ax1, assessment['risk_score'], 10)
            
            # Size trend
            ax2.set_title('Family Size')
            ax2.text(0.5, 0.5, f'{family_data["current_size"]}\nspecies',
                    ha='center', va='center', fontsize=24, weight='bold')
            ax2.set_xlim(0, 1)
            ax2.set_ylim(0, 1)
            ax2.axis('off')
            
            # Risk factors
            ax3.set_title('Risk Factor Breakdown')
            factors = ['Size', 'Growth', 'Hosts', 'Complexity', 'Coherence']
            values = [
                assessment['size_factor'],
                assessment['growth_factor'],
                assessment['host_factor'],
                assessment['complexity_factor'],
                assessment['coherence_factor']
            ]
            
            bars = ax3.barh(factors, values)
            ax3.set_xlim(0, 10)
            ax3.set_xlabel('Risk Contribution')
            
            # Color bars by risk level
            for bar, val in zip(bars, values):
                if val < 3:
                    bar.set_color('green')
                elif val < 7:
                    bar.set_color('orange')
                else:
                    bar.set_color('red')
            
            # Recommendations
            ax4.set_title('Recommendation')
            ax4.text(0.5, 0.7, assessment['intervention_type'],
                    ha='center', va='center', fontsize=18, weight='bold',
                    bbox=dict(boxstyle="round,pad=0.3", facecolor='lightblue'))
            
            if assessment['intervention_probability'] > 0:
                ax4.text(0.5, 0.3, 
                        f"3-Year Probability: {assessment['intervention_probability']:.0%}",
                        ha='center', va='center', fontsize=12)
            
            ax4.set_xlim(0, 1)
            ax4.set_ylim(0, 1)
            ax4.axis('off')
            
            plt.tight_layout()
            pdf.savefig(fig, bbox_inches='tight')
            plt.close()
        
        pdf_buffer.seek(0)
        return pdf_buffer.getvalue()
    
    def export_data_csv(self, assessments: List[Dict[str, Any]]) -> str:
        """Export assessment data as CSV."""
        
        df = pd.DataFrame(assessments)
        
        # Select and rename columns for export
        export_columns = {
            'family_name': 'Family',
            'current_size': 'Current Size',
            'growth_rate': 'Growth Rate',
            'risk_score': 'Risk Score',
            'risk_category': 'Risk Category',
            'intervention_type': 'Recommended Action',
            'intervention_probability': '3-Year Intervention Probability'
        }
        
        df_export = df[list(export_columns.keys())].rename(columns=export_columns)
        
        # Format percentages
        df_export['Growth Rate'] = (df_export['Growth Rate'] * 100).round(1).astype(str) + '%'
        df_export['3-Year Intervention Probability'] = (df_export['3-Year Intervention Probability'] * 100).round(0).astype(str) + '%'
        
        return df_export.to_csv(index=False)
    
    def export_data_json(self, assessments: List[Dict[str, Any]], 
                        include_metadata: bool = True) -> str:
        """Export assessment data as JSON."""
        
        export_data = {
            'assessments': assessments,
            'export_date': self.report_date.isoformat(),
            'total_families': len(assessments)
        }
        
        if include_metadata:
            export_data['metadata'] = {
                'version': '1.0',
                'model_accuracy': 0.85,
                'data_source': 'ICTV Master Species List',
                'risk_factors': [
                    'family_size',
                    'growth_rate',
                    'host_breadth',
                    'genome_complexity',
                    'phylogenetic_coherence'
                ]
            }
        
        return json.dumps(export_data, indent=2, default=str)
    
    def generate_meeting_minutes(self, 
                               meeting_data: Dict[str, Any],
                               decisions: List[Dict[str, Any]]) -> bytes:
        """Generate meeting minutes document."""
        
        pdf_buffer = io.BytesIO()
        
        with PdfPages(pdf_buffer) as pdf:
            fig = plt.figure(figsize=(8.5, 11))
            fig.patch.set_facecolor('white')
            ax = fig.add_subplot(111)
            ax.axis('off')
            
            # Header
            ax.text(0.5, 0.95, 'ICTV Committee Meeting Minutes',
                   ha='center', va='top', fontsize=18, weight='bold')
            
            ax.text(0.5, 0.90, meeting_data.get('date', self.report_date.strftime('%B %d, %Y')),
                   ha='center', va='top', fontsize=14)
            
            # Meeting info
            y_pos = 0.80
            ax.text(0.1, y_pos, f"Attendees: {meeting_data.get('attendees', 'N/A')}",
                   ha='left', va='top', fontsize=11)
            
            y_pos -= 0.05
            ax.text(0.1, y_pos, f"Duration: {meeting_data.get('duration', 'N/A')}",
                   ha='left', va='top', fontsize=11)
            
            # Decisions section
            y_pos -= 0.10
            ax.text(0.1, y_pos, 'Decisions:', 
                   ha='left', va='top', fontsize=12, weight='bold')
            
            y_pos -= 0.05
            for decision in decisions:
                ax.text(0.15, y_pos, 
                       f"• {decision['family']}: {decision['decision']} ({decision['vote']})",
                       ha='left', va='top', fontsize=10)
                y_pos -= 0.04
            
            pdf.savefig(fig, bbox_inches='tight')
            plt.close()
        
        pdf_buffer.seek(0)
        return pdf_buffer.getvalue()
    
    def _create_gauge_chart(self, ax, value, max_value):
        """Create a gauge chart for risk visualization."""
        
        # Create semicircle gauge
        theta = np.linspace(0, np.pi, 100)
        radius = 1
        
        # Background arc
        ax.plot(radius * np.cos(theta), radius * np.sin(theta), 
               color='lightgray', linewidth=20)
        
        # Value arc
        value_theta = theta[0:int(len(theta) * value / max_value)]
        
        # Color based on value
        if value < 3:
            color = 'green'
        elif value < 5:
            color = 'yellow'
        elif value < 7:
            color = 'orange'
        else:
            color = 'red'
        
        ax.plot(radius * np.cos(value_theta), radius * np.sin(value_theta),
               color=color, linewidth=20)
        
        # Center text
        ax.text(0, -0.2, f'{value:.1f}', ha='center', va='center',
               fontsize=24, weight='bold')
        
        ax.set_xlim(-1.5, 1.5)
        ax.set_ylim(-0.5, 1.5)
        ax.axis('off')
    
    def create_download_link(self, data: bytes, filename: str, 
                           file_type: str = 'pdf') -> str:
        """Create a base64 download link for Streamlit."""
        
        b64 = base64.b64encode(data).decode()
        
        mime_types = {
            'pdf': 'application/pdf',
            'csv': 'text/csv',
            'json': 'application/json'
        }
        
        mime = mime_types.get(file_type, 'application/octet-stream')
        
        return f'<a href="data:{mime};base64,{b64}" download="{filename}">Download {filename}</a>'